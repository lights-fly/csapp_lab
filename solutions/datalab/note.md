# datalab思路及方法
`datalab的实验分为两个部分：int和float。`

## int部分实验
<font color=skyblue size =2pp>实验对能使用的操作符和数据类型进行了限制，在int部分实验中使用的常数范围只能在`0x01~0xFF`，使用的数据类型只能是`int`，不能使用控制结构如`if, while, for，>, <`等</font>

### `0x00` bitXor
- int bitXor(int x, int y)
- 使用`~`和`&`实现一个异或函数  
  
  因为x与y的异或等价于 $\overline{x}y+x\overline{y}$,但是要求只能使用取反和与操作符，通过两次取反就可以转化成与非的形式。


### `0x01` tmin
- int tmin(void)
- 要求返回最小的补码，可以使用的操作符为`! ~ & ^ | + << >>`  
  
  对于位向量$[x_{w-1},x_{w-2}\cdots, x_{1}, x_{0}]$来说，当其表示为补码时，最高位$x_{w-1}$为符号位，对应的十进制的数为$X = -2^{w-1}\cdot x_{w-1} + \sum_{n=0}^{w-2}2^n\cdot x_n$，可以看出当符号位为1其余为0时所对应的数最小，通过将1左右31位即可得到最小的二进制补码。

### `0x02` isTmax
- int isTmax(int x)
- 判断x是否是最大的二进制补码，如果是就返回1， 否则返回0，可以使用的操作符为`! ~ & ^ | +`  
  
  对于补码$T$来说，$Tmax+1=Tmin$，对于$Tmax$有这样的特征，$Tmax+1 = \overline{Tmax}$，但是-1也有这个特征，所以需要在满足这个特征的同时不为-1，代码中`cond1`求的就是x是否满足这个特征，当其为1的时候代表满足特征，`cond2`代表是否为-1，当其为1的时候为真，当满足`cond1`为真且`cond2`为假的条件时x为Tmax。

### `0x03` allOldBits
- int allOldBits(int x)
- 如果x的所有奇数位为1，返回1，否则返回0，可用操作符`! ~ & ^ | + << >>`  
  
  一个数如果与一个所有奇数位都为1的数进行与运算之后，等于一个所有奇数位都为1的数，那么他就是一个奇数位都为1的数。

### `0x04` negate
- int negate(int x)
- 求`-x`，可用操作为`! ~ & ^ | + << >>`  
  补码并不是对称的，$-x = \overline x + 1$

### `0x05` isAsciiDigit
- int isAsciiDigit(int x)
- 判断x是否是ascii码0~9，即判断x是否在区间`[0x30,0x39]`之间，可用操作符`! ~ & ^ | + << >> `  
  
  采用循序渐进的办法，首先判断x是否在`[0x30,0x3F]`之间，接着判断x是否小于0x38，如果x大于0x38，判断x是否时0x39。综合来说，如果在`[0x30,0x3F]`之间成立的条件下，x小于0x38或者x等于0x38或0x39，那么x就在ascii码0~9之间，返回1。

### `0x06` conditional
- int conditional(int x, int y)
- 实现和 `x ? y : z`一样的功能，即x不为0时返回y，否则返回z，可用操作符为`! ~ & ^ | + << >>`  
  
  首先我们利用`~`判断x是否为0，并将这个结果赋值给`BOOL`，我们需要构建这样一个掩码，即当`BOOL`为0时返回全1的掩码，为1时返回全0的掩码，可以通过`mask = BOOL + (~0)`，并使返回值为`(mask & x) + ((~mask) & z) `,这样实现了x为0时返回z，x不为0时返回y。

### `0x07` isLessOrEqual
- int isLessOrEqual(int x, int y)
- 比较x和y的大小，如果x小于等于y返回1，否则返回0，可用操作符为`! ~ & ^ | + << >>`
  
  将这个问题分为三种情况：  
  `I.`x等于y，可以通过`is_equal = !(x^y)`求得    
  `II.`x的符号位与y的符号位相同，通过`x-y`的符号位来判断x和y的大小关系，由于不能使用`-`，通过`(~y) + 1`来获得`-y`  
  `III.`x的符号位与y的符号位不相同，通过符号来判断x大小关系

### `0x08` logicalNeg
- int logicalNeg(int x)
- 实现`!`的功能，即x不为0时返回0，可用操作为`~ & ^ | + << >>`

  当x不为0时，有两种情况：  
  `I.`x小于0，如果符号位是1，那么x小于1成立  
  `II.`x大于0，这个又可以再细分成两种情况`x等于1`和`x大于1`，前者可以通过直接与1异或操作判断，后者可以通过`x-1`的符号位判断  

  当满足这两个条件中的任一条件时，就返回0

### `0x09` howManyBits
- int howManyBits(int x)
- 判断用补码来表示x，最少所需的位数时多少，可用操作符为`! ~ & ^ | + << >>`

  `一个m位的补码，从最高位开始其前n位都相同，取该补码的第m-n+1位开始到低位作为一个新的补码，这个新的补码对应的十进制数与原来的补码相同`  
  由于x是int类型，所以其有32个bit，将x表示为$[x_{31},x_{30}\cdots, x_{1}, x_{0}]$，我们依次使用异或运算符`^`来计算相邻两个比bit是否相同。首先计算$x_{31} \wedge x_{30}$，接着是$x_{30} \wedge x_{29}$，以此类推，在这个过程中，我们需要判断从最高位开始到底有多少位是相同的。这里设置两个重要的变量`not_equal`与`bits_counter`，它们的初始值分别为0和1，首先，not_equal = $(x_{31} \wedge x_{30}) | not\_equal$，bits_counter = bits_counter + not_equal。如图1，在依次检测相邻两位是否相同的过程中，一旦有一次相邻两位相异，那么not_equal自此以后将始终为1，bits_couter在此时开始计数，最后，我们将得到从第一个与其后一位不同的bit开始，所有的bit总数，这要求bits_counter从1开始，因为当所有位都相等时，需要用长度为1位的补码来表示x。
  <center><img src="pictures/32.gif" width=500 height=240></center>

  <center> 图1 </center>

  下图2展示了$x_{31}$与$x_{30}$相同，$x_{30}$与$x_{29}$相异的情形。
  <center><img src="pictures/31.gif" width=500 height=240></center>  

  <center> 图2 </center>

  不过这一问题显然不可能使用 如此简单的方法进行解决，该题限制了最多的操作符使用次数为90次，我们估算一下按照上述方案所需的，32位bit移位需要使用31次>>，然后有对应的^、|、+操作，最后我们只取低四位作为返回值，还需要使用一次&这显然超过了90次的限制，为此，我们需要提高以上操作的效率。   
  将32个bit分为四个部分part3,part2,part1,part0，每个part为8个bit，这样做的原因是因为c语言的操作符是对所有位进行操作的。为此，我们需要一个掩码mask，其第0、8、16、24位需要位1，其他位为0。将x右移7~0位并分别与mask进行与运算，除此之外我们还要计算两个part相交处的异或情况，这在合并4个part时将是重要的条件。按照图1所示流程，就可以得到4个part的值，这个者表示使用补码表示这个part需要多少位bit。接下来，我们需要将4个part相加，当然不是简单的直接相加这么简单。  

  首先考虑part3，对于part3有两种情况，一种是part3就等于part3，一种是part3等于0。  

   - 当part3不等于0`或`part3的最低位与part2的最高位不相等时，part3就为part3
   - 当part3等于0`且`part3的最低位与part2的最高位相等时，part3等于0

  接着考虑part2，part2的值取决于part2的值
   - 当part3不等于0时，part2等于8
   - 当part3等于0`且`part2等于0，且part2的最低位和part1的最低位相等时，part2等于0
   - 在其余条件下，part2等于part2

  然后考虑part1，其过程和part2完全一致
   - 当part2不等于0时，part1等于8
   - 当part2等于0`且`part1等于0，且part1的最低位和part0的最低位相等时，part1等于0
   - 在其余条件下，part1等于part1

  最后考虑part0，part0需要考虑的相对简单
   - 当part1不等于0时，part0等于8
   - 当part1等于0时，part0等于part0

  最后，将part3~part0相加，并将结果和0xFF相与，即是最终的结果。


  
  

